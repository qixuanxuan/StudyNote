#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <map>
#include <set>
#include <string.h>
#include <cstring>
#include <set>
#include <utility>
#include <vector>
#include <sstream>
#include <stdlib.h>
#include <stdint.h>
using namespace std;
#define MAX_N 26
typedef struct DicTreeNode_S{
	int endCnt; // 词根结束标志
	struct DicTreeNode_S* childs[MAX_N];
}DicTreeNode;

DicTreeNode *g_root;

void AddNode(string &NodeX)
{
	int pos;
	DicTreeNode* p = g_root;
	for (int i = 0; i < NodeX.size(); i++) {
		pos = NodeX[i] - 'a';
		if (p->childs[pos] == NULL) {
			p->childs[pos] = (DicTreeNode*)malloc(sizeof(DicTreeNode));
			for (int j = 0; j < MAX_N; j++) {
				p->childs[pos]->childs[j] = NULL;
			}
			p->childs[pos]->endCnt = 0;
		}
		p = p->childs[pos];
	}
	p->endCnt++;
}


void CreateDicTree(vector<string> &stringList)
{
	g_root = (DicTreeNode*)malloc(sizeof(DicTreeNode));
	for (int i = 0; i < MAX_N; i++) {
		g_root->childs[i] = NULL;
	}
	g_root->endCnt = 0;
	for (int i = 0; i < stringList.size(); i++) {
		AddNode(stringList[i]);
	}
}

bool Search(string& s, string& out)
{
	DicTreeNode* p = g_root;
	int pos;
	for (int i = 0; i < s.size(); i++) {
		pos = s[i] - 'a';
		p = p->childs[pos];
		if (p == NULL) {
			return false;
		}
		else {
			if (p->endCnt == 1) {
				out = s.substr(0, i + 1);
				return true;
			}
		}
	}
	return false;
}

class Solution {
public:
	string replaceWords(vector<string>& dictionary, string sentence) {
		CreateDicTree(dictionary);
		stringstream StreamSentence(sentence);
		string IthSentence;
		string res = "";
		string outTmp;
        // 流按空格分割字符串
		while (StreamSentence >> IthSentence) {
			if (Search(IthSentence, outTmp)) {
				res += " ";
				res += outTmp;
			}
			else {
				res += " ";
				res += IthSentence;
			}
		}
		return res.substr(res.find_first_not_of(" "));
	}
};c
