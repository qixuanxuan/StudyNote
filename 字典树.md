#### [648. 单词替换](https://leetcode-cn.com/problems/replace-words/)

难度中等89

在英语中，我们有一个叫做 `词根`(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 `继承词`(successor)。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。

现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有`继承词`用`词根`替换掉。如果`继承词`有许多可以形成它的`词根`，则用最短的词根替换它。

你需要输出替换之后的句子。

 

**示例 1：**

```
输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"
```


```c
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <map>
#include <set>
#include <string.h>
#include <cstring>
#include <set>
#include <utility>
#include <vector>
#include <sstream>
#include <stdlib.h>
#include <stdint.h>
using namespace std;
#define MAX_N 26
typedef struct DicTreeNode_S{
	int endCnt; // 词根结束标志
	struct DicTreeNode_S* childs[MAX_N];
}DicTreeNode;

DicTreeNode *g_root;

void AddNode(string &NodeX)
{
	int pos;
	DicTreeNode* p = g_root;
	for (int i = 0; i < NodeX.size(); i++) {
		pos = NodeX[i] - 'a';
		if (p->childs[pos] == NULL) {
			p->childs[pos] = (DicTreeNode*)malloc(sizeof(DicTreeNode));
			for (int j = 0; j < MAX_N; j++) {
				p->childs[pos]->childs[j] = NULL;
			}
			p->childs[pos]->endCnt = 0;
		}
		p = p->childs[pos];
	}
	p->endCnt++;
}


void CreateDicTree(vector<string> &stringList)
{
	g_root = (DicTreeNode*)malloc(sizeof(DicTreeNode));
	for (int i = 0; i < MAX_N; i++) {
		g_root->childs[i] = NULL;
	}
	g_root->endCnt = 0;
	for (int i = 0; i < stringList.size(); i++) {
		AddNode(stringList[i]);
	}
}

bool Search(string& s, string& out)
{
	DicTreeNode* p = g_root;
	int pos;
	for (int i = 0; i < s.size(); i++) {
		pos = s[i] - 'a';
		p = p->childs[pos];
		if (p == NULL) {
			return false;
		}
		else {
			if (p->endCnt == 1) {
				out = s.substr(0, i + 1);
				return true;
			}
		}
	}
	return false;
}

class Solution {
public:
	string replaceWords(vector<string>& dictionary, string sentence) {
		CreateDicTree(dictionary);
		stringstream StreamSentence(sentence);
		string IthSentence;
		string res = "";
		string outTmp;
        // 流按空格分割字符串
		while (StreamSentence >> IthSentence) {
			if (Search(IthSentence, outTmp)) {
				res += " ";
				res += outTmp;
			}
			else {
				res += " ";
				res += IthSentence;
			}
		}
		return res.substr(res.find_first_not_of(" "));
	}
};c

```

